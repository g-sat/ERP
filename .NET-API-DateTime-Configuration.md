# .NET API DateTime Configuration Guide

## Problem

When frontend sends `2025-12-27T22:15:00.000Z` (UTC), .NET API converts it to Dubai time (+4 hours) and stores `2025-12-28 00:15:00` in database. We want to store the exact time entered without timezone conversion.

## Solution 1: Frontend (Already Implemented)

Frontend now sends DateTime **without timezone indicator** (`Z`):

- Format: `yyyy-MM-ddTHH:mm:ss.SSS` (e.g., `2025-12-27T22:15:00.000`)
- .NET will treat this as **local time** (Dubai timezone) and store as-is

## Solution 2: .NET API Configuration

### Option A: Configure JSON Serialization (Recommended)

#### For ASP.NET Core (System.Text.Json)

**In `Program.cs` or `Startup.cs`:**

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;

var builder = WebApplication.CreateBuilder(args);

// Configure JSON options to handle DateTime without timezone conversion
builder.Services.Configure<JsonOptions>(options =>
{
    options.SerializerOptions.Converters.Add(new JsonStringEnumConverter());

    // Handle DateTime as local time (Dubai timezone)
    // This ensures DateTime without timezone is treated as local time
    options.SerializerOptions.Converters.Add(new DateTimeConverter());
});

var app = builder.Build();
```

**Create `DateTimeConverter.cs`:**

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;

public class DateTimeConverter : JsonConverter<DateTime>
{
    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
        {
            var dateString = reader.GetString();

            // If string ends with 'Z' or has timezone, parse as UTC then convert to local
            if (dateString != null && (dateString.EndsWith("Z") || dateString.Contains("+")))
            {
                var utcDate = DateTime.Parse(dateString, null, System.Globalization.DateTimeStyles.RoundtripKind);
                return utcDate.ToLocalTime(); // Convert to Dubai timezone
            }

            // If no timezone indicator, treat as local time (Dubai)
            if (DateTime.TryParse(dateString, out var localDate))
            {
                return DateTime.SpecifyKind(localDate, DateTimeKind.Local);
            }
        }

        // Fallback
        return reader.GetDateTime();
    }

    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
    {
        // Write as ISO 8601 without timezone
        writer.WriteStringValue(value.ToString("yyyy-MM-ddTHH:mm:ss.fff"));
    }
}

// For nullable DateTime
public class NullableDateTimeConverter : JsonConverter<DateTime?>
{
    public override DateTime? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.Null)
            return null;

        var converter = new DateTimeConverter();
        return converter.Read(ref reader, typeof(DateTime), options);
    }

    public override void Write(Utf8JsonWriter writer, DateTime? value, JsonSerializerOptions options)
    {
        if (value == null)
            writer.WriteNullValue();
        else
        {
            var converter = new DateTimeConverter();
            converter.Write(writer, value.Value, options);
        }
    }
}
```

#### For ASP.NET Core (Newtonsoft.Json)

**In `Program.cs` or `Startup.cs`:**

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

builder.Services.AddControllers()
    .AddNewtonsoftJson(options =>
    {
        // Configure DateTime handling
        options.SerializerSettings.DateTimeZoneHandling = DateTimeZoneHandling.Local;
        options.SerializerSettings.DateFormatString = "yyyy-MM-ddTHH:mm:ss.fff";

        // Custom converter for DateTime
        options.SerializerSettings.Converters.Add(new DateTimeConverter());
    });
```

**Create `DateTimeConverter.cs` (Newtonsoft.Json):**

```csharp
using Newtonsoft.Json;
using System;

public class DateTimeConverter : JsonConverter<DateTime>
{
    public override DateTime ReadJson(JsonReader reader, Type objectType, DateTime existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
        if (reader.Value == null)
            return default(DateTime);

        var dateString = reader.Value.ToString();

        // If has timezone indicator, parse as UTC then convert to local
        if (dateString.EndsWith("Z") || dateString.Contains("+") || dateString.Contains("-", 10))
        {
            var utcDate = DateTime.Parse(dateString, null, System.Globalization.DateTimeStyles.RoundtripKind);
            return utcDate.ToLocalTime();
        }

        // No timezone = treat as local time (Dubai)
        var localDate = DateTime.Parse(dateString);
        return DateTime.SpecifyKind(localDate, DateTimeKind.Local);
    }

    public override void WriteJson(JsonWriter writer, DateTime value, JsonSerializer serializer)
    {
        // Write without timezone indicator
        writer.WriteValue(value.ToString("yyyy-MM-ddTHH:mm:ss.fff"));
    }
}
```

### Option B: Use DateTimeOffset (Alternative Approach)

**In your DTO/Model classes:**

```csharp
public class JobOrderDto
{
    // Use DateTimeOffset to preserve timezone info
    public DateTimeOffset? EtaDate { get; set; }
    public DateTimeOffset? EtdDate { get; set; }

    // Or use DateTime and handle conversion in controller
    public DateTime? LoadingTime { get; set; }
}
```

**In Controller:**

```csharp
[HttpPost]
public async Task<IActionResult> CreateJobOrder([FromBody] JobOrderDto dto)
{
    // If using DateTimeOffset, convert to DateTime for database
    var jobOrder = new JobOrder
    {
        EtaDate = dto.EtaDate?.DateTime, // Convert to local DateTime
        EtdDate = dto.EtdDate?.DateTime,
    };

    // Save to database
    await _context.JobOrders.AddAsync(jobOrder);
    await _context.SaveChangesAsync();

    return Ok(jobOrder);
}
```

### Option C: Entity Framework Configuration

**In your `DbContext` or Entity Configuration:**

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

public class ApplicationDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure DateTime columns to store as-is (no timezone conversion)
        var dateTimeConverter = new ValueConverter<DateTime, DateTime>(
            v => v, // Store as-is
            v => DateTime.SpecifyKind(v, DateTimeKind.Local) // Read as local
        );

        // Apply to all DateTime properties
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            foreach (var property in entityType.GetProperties())
            {
                if (property.ClrType == typeof(DateTime) || property.ClrType == typeof(DateTime?))
                {
                    property.SetValueConverter(dateTimeConverter);
                }
            }
        }
    }
}
```

### Option D: Set Server Timezone to Dubai

**In `Program.cs` or `Startup.cs`:**

```csharp
// Set application timezone to Dubai (UTC+4)
TimeZoneInfo dubaiTimeZone = TimeZoneInfo.FindSystemTimeZoneById("Arabian Standard Time");
// Or for Linux: "Asia/Dubai"

// Configure system default
System.TimeZoneInfo.Local = dubaiTimeZone;
```

**Note:** This affects the entire application. Use with caution.

## Recommended Solution

**Use Option A (JSON Serialization Configuration)** - This is the cleanest approach:

1. ✅ Handles DateTime parsing correctly
2. ✅ No timezone conversion
3. ✅ Works with existing code
4. ✅ Easy to maintain

## Testing

After implementing, test with:

```json
{
  "etaDate": "2025-12-27T22:15:00.000",
  "etdDate": "2025-12-28T14:30:00.000"
}
```

**Expected Result in Database:**

- `etaDate`: `2025-12-27 22:15:00.000` (stored as-is, no conversion)
- `etdDate`: `2025-12-28 14:30:00.000` (stored as-is, no conversion)

## Database Column Type

Ensure your database columns are:

- **SQL Server**: `datetime2` or `datetime`
- **MySQL**: `DATETIME` (not `TIMESTAMP` - which auto-converts)
- **PostgreSQL**: `timestamp without time zone`

**Avoid:** `TIMESTAMP` in MySQL (auto-converts to UTC)
